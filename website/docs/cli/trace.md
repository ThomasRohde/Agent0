---
sidebar_position: 5
---

# a0 trace

Summarize a JSONL execution trace file produced by `a0 run --trace`.

## Usage

```bash
a0 trace <file> [options]
```

The `<file>` argument is a `.jsonl` trace file generated by [`a0 run --trace`](./run.md).

## Flags

| Flag | Description |
|------|-------------|
| `--json` | Output the summary as JSON instead of human-readable text |

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Summary produced successfully |
| 4 | Error reading file or no valid trace events found |

## Trace Events

A0 emits 16 trace event types during execution. Each event is a JSON object written as one line in the JSONL file.

| Event | Description |
|-------|-------------|
| `run_start` | Program execution begins |
| `run_end` | Program execution completes (includes error if failed) |
| `stmt_start` | A statement begins executing |
| `stmt_end` | A statement finishes executing |
| `tool_start` | A tool call begins (`call?` or `do`) |
| `tool_end` | A tool call completes (includes outcome: `ok` or `err`) |
| `evidence` | An `assert` or `check` produces an evidence record |
| `budget_exceeded` | A budget limit was reached |
| `for_start` | A `for` loop begins |
| `for_end` | A `for` loop completes |
| `fn_call_start` | A function call begins (user-defined or stdlib) |
| `fn_call_end` | A function call completes |
| `match_start` | A `match` expression begins evaluation |
| `match_end` | A `match` expression completes |
| `map_start` | A `map` operation begins |
| `map_end` | A `map` operation completes |

### Event Structure

Each trace event has this shape:

```json
{
  "ts": "2025-01-15T10:30:00.000Z",
  "runId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "event": "tool_start",
  "span": { "file": "program.a0", "startLine": 4, "startCol": 1 },
  "data": { "tool": "http.get" }
}
```

## Summary Output

The `a0 trace` command reads all events and produces a summary with:

- **Run ID** -- unique identifier for the execution
- **Total events** -- number of trace events recorded
- **Tool invocations** -- how many tool calls were made
- **Tools used** -- breakdown of calls per tool name
- **Evidence events** -- how many `assert`/`check` evidence records
- **Failures** -- tool errors, failed evidence, or runtime errors
- **Budget exceeded** -- how many times a budget limit was hit
- **Duration** -- wall-clock time from `run_start` to `run_end`

## Examples

### Generate a Trace

First, run a program with `--trace`:

```bash
a0 run examples/fetch-transform.a0 --trace trace.jsonl --unsafe-allow-all
```

### Summarize the Trace

```bash
a0 trace trace.jsonl
```

Output:

```
Trace Summary
  Run ID:           a1b2c3d4-e5f6-7890-abcd-ef1234567890
  Total events:     12
  Tool invocations: 2
  Tools used:
    http.get: 1
    fs.write: 1
  Evidence events:  0
  Failures:         0
  Budget exceeded:  0
  Duration:         342ms
```

### JSON Output

For programmatic consumption, use `--json`:

```bash
a0 trace trace.jsonl --json
```

```json
{
  "runId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "totalEvents": 12,
  "toolInvocations": 2,
  "toolsByName": {
    "http.get": 1,
    "fs.write": 1
  },
  "evidenceCount": 0,
  "failures": 0,
  "budgetExceeded": 0,
  "startTime": "2025-01-15T10:30:00.000Z",
  "endTime": "2025-01-15T10:30:00.342Z",
  "durationMs": 342
}
```

### Debugging with Traces

Traces are particularly useful for understanding runtime behavior when a program fails:

```bash
# Run with trace, allowing all caps for debugging
a0 run failing-program.a0 --trace debug.jsonl --unsafe-allow-all --pretty

# Check what happened
a0 trace debug.jsonl
```

The trace shows exactly which tools were called, in what order, and which ones failed. See the [Debugging Guide](../errors/debugging-guide.md) for a complete workflow.
